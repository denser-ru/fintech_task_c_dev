# fintech_task_c_dev
*Trial task when applying for a job*

Подробное описание задания в [файле](https://github.com/denser-ru/fintech_task_c_dev/blob/dev/task/task_c_dev.pdf)

> Для учебных целей и большего контроля работы
> приложения использовался минимальный набор из 2 системных вызовов
> read, write и 2 функций malloc и free библиотеки glibc.  

Для испытания различных подходов в оптимизации ввода и вывода данных использованы следующие рабочие версии:

| Версия | Описание |
| ------ | ------ |
|[dev-v1.x-gnl_l](https://github.com/denser-ru/fintech_task_c_dev/tree/dev-v1.x-gnl_l) | Использовал собственную "облегчённую" функцию gnl_l() с однократныйм выделением памяти на стеке функции для чтения ввода|
|[dev-v1.x-getline_m2](https://github.com/denser-ru/fintech_task_c_dev/tree/dev-v1.x-getline_m2) |  Использовал для чтения из stdin системную функцию getline() с вызовом malloc() и free() однократно |
|[dev-v1.x-getline_m](https://github.com/denser-ru/fintech_task_c_dev/tree/dev-v1.x-getline_m) | Использовал для чтения из stdin системную функцию getline() с вызовом malloc() и free() при каждом чтении |
|[dev-v1.x-printf](https://github.com/denser-ru/fintech_task_c_dev/tree/dev-v1.x-printf) | Использовал для вывода системную функцию printf() |
|[dev-v.1.x](https://github.com/denser-ru/fintech_task_c_dev/tree/dev-v1.x) | Использована оптимизация - сортировки на вставке, когда новый элемент встравивается в список сразу в порядке сортировки |

### Результаты измерений

> Для измерения использовался скрипт на bash (tests/run_test.sh), который n-количество раз
> подавал на входы данные для каждой версии приложения.
> За первым разом использовался файл из задания input.txt.
> За вторым файл с содержимым файла input.txt 10 раз повторенным.

input.txt:
```
Установлено значени количества измерений на одну версию - 100
Версия dev-v1.x 	--> 	min: 0.0516; max: 0.0621; avr: 0.0558
Версия dev-v1.x-printf 	--> 	min: 0.0516; max: 0.0625; avr: 0.0566
Версия dev-v1.x-getline_m 	--> 	min: 0.0507; max: 0.0604; avr: 0.0549
Версия dev-v1.x-getline_m2 	--> 	min: 0.0507; max: 0.0602; avr: 0.0547
Версия dev-v1.x-gnl_l 	--> 	min: 0.0481; max: 0.0597; avr: 0.0541
***********
```
input10.txt:
```
Установлено значени количества измерений на одну версию - 10
Версия dev-v1.x 	--> 	min: 03.9918; max: 07.4191; avr: 05.1992
Версия dev-v1.x-printf 	--> 	min: 03.9918; max: 07.2165; avr: 05.4984
Версия dev-v1.x-getline_m 	--> 	min: 03.9918; max: 011.5887; avr: 08.6196
Версия dev-v1.x-getline_m2 	--> 	min: 03.9918; max: 09.5281; avr: 06.8240
Версия dev-v1.x-gnl_l 	--> 	min: 03.7928; max: 09.4541; avr: 07.1781
***********
```

## Выводы
При небольшом количестве порций данных на вход все версии дали результаты с незначительными различиями.
При больших объёмах заметно лучшие показатели у версии dev-v1.x, которая пытается считать всю порцию целиком
#### Идеи дальнейших оптимизаций
 - Можно попробовать ещё оптимизировать функцию чтения стандартного ввода для случаев с большими объёмами на входе
 - Попробовать использовать единый буфер для хранения всех элементов списка, избегая регулярные вызовы malloc() и free(). Ранее на проекте воспроизводящем работу стандартного приложения "ls" удалось увеличить скорость рекурсивного обхода до 50%.
 
### libft
Здесь приеняется самописная библиотека наиболее часто используемых в моих проектах функций.


## License

MIT

**Free Software, Hell Yeah!**